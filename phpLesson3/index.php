<?
/*
1. С помощью цикла while вывести все числа в промежутке от 0 до 100, которые делятся на 3 без остатка.
*/
echo 'Задание 1.<br> С помощью цикла while вывести все числа в промежутке от 0 до 100, которые делятся на 3 без остатка.<br><br>';

$i = 0;
while ($i <= 100) {
	if ($i%3 == 0) { 
		echo $i . ' ';
	}
	$i++;
}

/*
2. С помощью цикла do…while написать функцию для вывода чисел от 0 до 10, чтобы результат выглядел так:
0 – это ноль.
1 – нечетное число.
2 – четное число.
3 – нечетное число.
…
10 – четное число.
*/

echo '<hr>Задание 2.<br>';
echo  '<br>С помощью цикла do…while написать функцию для вывода чисел от 0 до 10<br><br>';
$i = 0;
do {
	if ($i == 0) {
		echo "$i – это ноль.<br>";
	}
	elseif ($i%2 == 0) {
		echo "$i – чётное число.<br>";
	}
	else {
		echo "$i – нечётное число.<br>";
	}
	$i++;
} while ($i <= 10);		


/*
3. Объявить массив, в котором в качестве ключей будут использоваться названия областей, а в качестве значений – массивы с названиями городов из соответствующей области. Вывести в цикле значения массива, чтобы результат был таким:
Московская область:
Москва, Зеленоград, Клин
Ленинградская область:
Санкт-Петербург, Всеволожск, Павловск, Кронштадт
Рязанская область … (названия городов можно найти на maps.yandex.ru)
*/
echo '<hr>Задание 3, 8.<br>';
$regions = [
	"Московская область" => [
		"Москва",
		"Зеленоград",
		"Клин"
		],
	"Ленинградская область" => [
		"Санкт-Петербург",
		"Всеволожск",
		"Павловск",
		"Кронштадт",
	],
	"Рязанская область" => [
		"Рязань",
		"Скопин",
		"Касимов",
		"Сасово",
		"Ряжск"
	]
];
?>
<pre>
<?
print_r($regions);
?>
</pre>
<br>
<?

echo '<h3>вывести на экран только города, начинающиеся с буквы «К».</h3>';
foreach ($regions as $key => $value) {
	//echo print_r($value);
	 for($i = 0; $i < count($value); $i++ ){
		 // сравниваем подстроку длиной в 1 символ с 0-й позиции в кодировке utf8 (совместимость с PHP5.6)
		 // и приведенной к нижнему регистру

		if  (mb_substr(mb_strtolower($value[$i],'utf8'),0,1,'utf8') == 'к') { 
		//if  ($value[$i][0] == 'К') { // первый элемент строки. у функции проблемы с кодировкой, к сожалению и в PHP7.2. php.ini  сервер не дает перезаписать
			echo $value[$i] . '<br>';
		}
	}
}
?>
<br>
<?
/*
4. Объявить массив, индексами которого являются буквы русского языка, а значениями – соответствующие латинские буквосочетания ('а'=> 'a', 'б' => 'b', 'в' => 'v', 'г' => 'g', …, 'э' => 'e', 'ю' => 'yu', 'я' => 'ya').
Написать функцию транслитерации строк.
*/
echo '<hr><h3>Задание 4,5, 9. <br> Написать функцию транслитерации строк.</h3>';

echo '<h3>Транслитерация любых строк</h3>';

// Транслитерация любых строк
function translitStr($str) {
	$letters = [
		'а' => 'a',	 'б' => 'b',  'в' => 'v',  'г' => 'g',	'д' => 'd',  'е' => 'e', 
		'ё' => 'e',	 'ж' => 'j',  'з' => 'z',  'и' => 'i',  'й' => 'y',  'к' => 'k', 
		'л' => 'l',	 'м' => 'm',  'н' => 'n',  'о' => 'o',  'п' => 'p',  'р' => 'r', 
		'с' => 's',	 'т' => 't',  'у' => 'u',  'ф' => 'f',  'х' => 'h',  'ц' => 'ts', 
		'ч' => 'ch', 'ш' => 'sh', 'щ' => 'shh', 'ы' => 'i', 'э' => 'e',  'ю' => 'yu', 'я' => 'ya',
		
		'А'=> 'A',    'Б' => 'B',  'В' => 'V',  'Г' => 'G', 'Д' => 'D',  'Е' => 'E', 
		'Ё' => 'E',   'Ж' => 'J',  'З' => 'Z',  'И' => 'I', 'Й' => 'Y',  'К' => 'K', 
		'Л' => 'L',   'М' => 'M',  'Н' => 'N',  'О' => 'O', 'П' => 'P',  'Р' => 'R', 
		'C' => 'S',   'Т' => 'T',  'У' => 'U',  'Ф' => 'F', 'Х' => 'H',  'Ц' => 'Ts', 
		'Ч' => 'Ch',  'Ш' => 'Sh', 'Щ' => 'Shh', 'Ы' => 'I','Э' => 'E', 'Ю' => 'Yu', 'Я' => 'Ya', 'Ь' => '', 'Ъ' => ''
	];
	//замена каждого элемента строки в соответствии с массивом "from" => "to"
	return strtr($str,$letters);
}

$strFrom = 'strtr() может вызываться с двумя аргументами. В этом случае from должен быть массивом (array), в форме array("from" => "to", ...). ';
//$strTo   = ;
//print_r('<br>' . $strTo);

echo '<br>' . $strFrom;
echo '<br>' . translitStr($strFrom);

echo '<h3>Транслитерация заголовков для url<br><br>с регулярным выражением</h3>';

function translitUrl($str) {
// Транслитерация заголовков для url
// с регулярным выражением

	$str = mb_strtolower($str,'utf8'); // к нижнему регистру в кодировке utf8(совместимость с PHP5.6)
	
	$letters = [
		'а'=> 'a',	 'б' => 'b',  'в' => 'v',  'г' => 'g',	'д' => 'd',  'е' => 'e', 
		'ё' => 'e',	 'ж' => 'j',  'з' => 'z',  'и' => 'i',  'й' => 'y',  'к' => 'k', 
		'л' => 'l',	 'м' => 'm',  'н' => 'n',  'о' => 'o',  'п' => 'p',  'р' => 'r', 
		'с' => 's',	 'т' => 't',  'у' => 'u',  'ф' => 'f',  'х' => 'h',  'ц' => 'ts', 
		'ч' => 'ch', 'ш' => 'sh', 'щ' => 'shh', 'ы' => 'i','э' => 'e',  'ю' => 'yu', 'я' => 'ya', 'ь' => '', 'ъ' => '',
		
	];
	
	$str = preg_replace('~[^-a-zа-я0-9_]+~u', '-', $str);
	// ~ (тильда) разделитель. начало и конец регулярного выражения. Можно использовать (), /, #
	// u включает работу с кириллицей UTF-8 (совместимость с PHP5.6)
	// [] ограничивают символы, которые в них заключены
	// [^]  отрицание: значок ^ обязательно в квадратных скобках! т.е.: Только не эти символы!
	// [^-a-zа-я0-9_] букквы от a до z в нижнем регистре, цифры от 0-9, дефис "-" и подчеркивание "_";
	//+  1 и более символов
	
	
	//http://max22.ru/php/php-reg/  список всех 
	
	$str = preg_replace('~\-{2,}~u', '-', $str); 
	//  \- экранируется. Т.к. в данном случае - обычный символ, а не диапазон значений
	//  {2,} встречается 2 и больше раз 
	// u включает работу с кириллицей UTF-8 (совместимость с PHP5.6)
	
	$str = trim($str,'-'); // обрезаем дефисы в начале и конце строки
	
	return strtr($str,$letters);
}
echo '<br>' . $strFrom; 
echo '<br>' . translitUrl($strFrom);



echo '<h3>Транслитерация заголовков для url<br><br>без регулярных  выражениий</h3>';
// Транслитерация заголовков для url
// без регулярных выражений



function translitUrlFor($str) {
	// Транслитерация заголовков для url
	// без регулярных выражений
	// совместимая с  PHP5.6
	$str = mb_strtolower($str,'utf8'); // к нижнему регистру в кодировке utf8 (совместимость с PHP5.6)

	$letters = [
		'а'=> 'a',	 'б' => 'b',  'в' => 'v',  'г' => 'g',	'д' => 'd',  'е' => 'e', 
		'ё' => 'e',	 'ж' => 'j',  'з' => 'z',  'и' => 'i',  'й' => 'y',  'к' => 'k', 
		'л' => 'l',	 'м' => 'm',  'н' => 'n',  'о' => 'o',  'п' => 'p',  'р' => 'r', 
		'с' => 's',	 'т' => 't',  'у' => 'u',  'ф' => 'f',  'х' => 'h',  'ц' => 'ts', 
		'ч' => 'ch', 'ш' => 'sh', 'щ' => 'shh', 'ы' => 'i','э' => 'e',  'ю' => 'yu', 'я' => 'ya', 'ь' => '', 'ъ' => '',
		
		'a' => 'a',  'b' => 'b', 'c' => 'c', 'd' => 'd', 'e' => 'e', 'f' => 'f', 'g' => 'g',
		'h' => 'h',  'i' => 'i', 'j' => 'j', 'k' => 'k', 'l' => 'l', 'm' => 'm', 'n' => 'n',
		'o' => 'o',  'p' => 'p', 'q' => 'q', 'r' => 'r', 's' => 's', 't' => 't', 'u' => 'u',
		'v' => 'v',  'w' => 'w', 'x' => 'x', 'y' => 'y', 'z' => 'z'
	];
	
	for ($i = 0,$arr = []; $i < strlen($str); $i++) {
		$isFound =0; // если не обнаружен элемент массива 
		foreach ($letters as $key => $value) {
			// explode php 5.6 для строк в кодировке UTF8 не работает, str_split работает с регулярными выражениями.
			// поэтому ввожу новую переменную -- массив arr
			if (mb_substr($str,$i,1,'utf8') == $key) { // сравниваем подстроку длиной в 1 символ с i-й позиции в кодировке utf8 (совместимость с PHP5.6)
				$arr[$i] = $value; //пополняем массив новых значений
				$isFound = 1; // обнаружено совпадение, пополняем массив новых значений
			}
		}
		if ($isFound == 0) { // не обнаружено совпадение
			$arr[$i] = '-'; //заменяем все НЕбуквы дефисами
		}
	}
	$str = implode($arr);
	$str = trim($str,'-'); // обрезаем - в конце и в начале строки

	while ( stripos($str,'--') !== false) { //замена всех дублирующихся дефисов
		$str = str_replace('--', '-',$str);
	}
	
	return $str;
}

echo '<br>' . $strFrom; 
echo '<br>' . translitUrlFor($strFrom);

/*
7. *Вывести с помощью цикла for числа от 0 до 9, НЕ используя тело цикла. То есть выглядеть должно так:
for (…){ // здесь пусто}
*/
echo '<hr>Задание 8. <br>';

echo '<h3>Вывести с помощью цикла for числа от 0 до 9, НЕ используя тело цикла. ';
for ($i = 0; $i <= 9; print_r($i++)) {}
?>


